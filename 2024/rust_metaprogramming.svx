---
title: "Rust Metaprogramming"
summary: "They say macros are Rust equivalent of C++ metaprograming; I beg to differ."
tags:
  - Rust
  - metaprogramming
  - abstraction
---

For one of my classes I wrote a discrete event simulation library in Rust. The
reason I wrote it was...

- I like Rust.
- I did very little reasearch into existing libraries.
- I needed filler for the essay as I covered the assigned topic and didn't have
  very many pages.

First of all, event simulation is a weird topic. While lookig up related
literature and resources I got a vibe that it was much more popular 10-ish years
ago, and I'm not sure why the hype died down. In library space there's very few
solutions being actively maintained.

Notable ones (from my limited search) are
[`sympy`](https://gitlab.com/team-simpy/simpy) and
[`asynchronix`](https://github.com/asynchronics/asynchronix).

## Introduction

I wanted to build something dumb simple to use that doesn't have as steep
learning curve as some other solutions in the space so I made
[`litesim`](https://github.com/Caellian/litesim) (and descibed it in the essay
ðŸ˜„).

### LiteSim

Cool thing about litesim is that it basically erases all simulation internals
and leaves you with a clean slate. It's based on
[DEVS](https://en.wikipedia.org/wiki/DEVS) so the whole simulation is built out
of composable models. The only structs the user needs to interact with are
`SystemModel` and `Simulation`.

A simple ping-pong example requires less than 50 lines of code and very little
understanding of how the library works:

```rust
use litesim::prelude::*;

pub struct Player;

#[litesim_model]
impl<'s> Model<'s> for Player {
    #[input(signal)]
    fn receive(&mut self, ctx: ModelCtx<'s>) -> Result<(), SimulationError> {
        ctx.schedule_update(Now)?;
        Ok(())
    }

    #[output(signal)]
    fn send(&self) -> Result<(), SimulationError>;

    fn handle_update(&mut self, ctx: ModelCtx<'s>) -> Result<(), SimulationError> {
        log::info!(
            "Player {} got the ball at {}",
            ctx.model_id.as_ref(),
            ctx.time
        );
        self.send(In(ctx.rand_range(0.0..1.0)))?;
        Ok(())
    }
}

fn main() {
    env_logger::builder()
        .filter_level(log::LevelFilter::Info)
        .init();

    let mut system = SystemModel::new();

    system.push_model("p1", Player);
    system.push_model("p2", Player);

    system.push_route(connection!(p1::send), connection!(p2::receive));
    system.push_route(connection!(p2::send), connection!(p1::receive));

    let mut sim = Simulation::new(rand::thread_rng(), system, 0.0).expect("invalid model");

    sim.schedule_event(0.5, Signal(), connection!(p1::receive))
        .expect("unable to schedule initial event");

    sim.run_until(50.0).expect("simulation error");
}
```

Most of the heavy lifting is done by the `#[litesim_model]` proc macro. This
macro does a lot of code transformation in the background in order to make the
`impl` block look as simple as it does.

In minimal form, implementing `Model<'s>` with it looks like:
```rust
#[litesim_model]
impl<'s> Model<'s> for MyModel {}
```

The _generated code is type safe_, but if the user implements the `Model<'s>`
trait without the macro, they're allowed to send arbitrary data into outputs
which is not ideal. The macro ensures correctess by filling in specified output
parameter types manually into invoked function signature, but bad inputs really
only fail bacause argument and specified generic types don't match, not because
the function doesn't exist or some bounds weren't satisfied.

That's bad because the library assumes the provided type will be the same as the
one specified on the connecting input connector of another model. The other
model (generally) can't tell the adress doesn't hold a valid type which can then
cause undefined behavior. Even assuming the layout of both types is identical,
it's still a semantic error and likely violates the API of the recieving model.

There is no sane way to support this use case without resorting to type
metaprogramming. Macros can't handle the use case where `Model<'s>` might change
interface and lookup table(s) based on types litesim isn't aware of. So in order
to tackle this, I'd like to replace `Model<'s>` with something like:
```rust
type Model<'s, I, O> {
  // details...
}
```

## Metaprogramming theory

We're trying to specify different model inputs/outputs as a list of types. Rust
doesn't have variable argument generics
([yet](https://github.com/rust-lang/rfcs/issues/376)), but it does have
primitive that can convey similar information - **tuples**.

Tuple is a runtime type though and the language doesn't have support for
operations we expect a list to support, and specifically doesn't support them
for _types_. Traits allow us however to add such information and `rustc` can
deal with it properly.

In order to have a useful type list, we need methods to at least:
- access type list **size**,
- access **head** element,
- access list **tail**,
- access n-th element, and
- check if `T` is contained in the list.

Type lists in C++ metaprogramming are built on the same principles, though they
are nicer to work with because of vararg generic support. Ideally, our _type
list_ type would be zero sized but given that tuples _are_ sized we can get around it by storing our type list as an empty array (`[TypeList; 0]`). `Phantom` might be more appropriate for this kind of use though.

## Practice

We start by defining a trait we can use to specify some arbitrary type list. Due
to lack of vararg generics there will be an upper bound to our list but thanks
to macros we can make it arbitrarily large. Relistically, we don't expect models
with more than 64 inputs and outputs.

We declare our list trait with some basic properties:
```rust
trait TypeList {
    type Head;
    type Tail: TypeList;
}
```

Now we can start implementing it for tuples we want to support:
```rust
impl TypeList for () {
    type Head = !;
    type Tail = ();
}
// Uhm...
```
We can't use never type `!` yet so we'll resort to using `()` instead. This
leaves us with no way to check if we're done iterating over our list so we need
to add that missing information. Given that the code for tuples will be
generated anyway, it's straightforward enough to add a `SIZE` constant.


```rust
trait TypeList {
    const SIZE: usize;
    type Head;
    type Tail: TypeList;
}

impl TypeList for () {
    const SIZE: usize = 0;
    type Head = ();
    type Tail = ();
}

impl<A> TypeList for (A,) {
    const SIZE: usize = 1;
    type Head = A;
    type Tail = ();
}

impl<A, B> TypeList for (A, B) {
    const SIZE: usize = 2;
    type Head = A;
    type Tail = (B,);
}

impl<A, B, C> TypeList for (A, B, C) {
    const SIZE: usize = 3;
    type Head = A;
    type Tail = (B, C);
}
// 61 more...
```

Now that we've written out the first four cases, we can politely ask our
friendly neighborhood LLM to convert it into a macro for us:
<div data-copy/>

```rust
macro_rules! impl_type_list {
    () => {
        impl TypeList for () {
            const SIZE: usize = 0;
            type Head = ();
            type Tail = ();
        }
    };
    
    ($A:ident) => {
        impl<$A> TypeList for ($A,) {
            const SIZE: usize = 1;
            type Head = $A;
            type Tail = ();
        }
    };
    
    ($A:ident, $($B:ident),*) => {
        impl<$A, $($B),*> TypeList for ($A, $($B),*) {
            const SIZE: usize = 1 + <($($B,)*) as TypeList>::SIZE;
            type Head = $A;
            type Tail = ($($B,)*);
        }
    };
}
```

And apply some magic I picked up from
[`piccolo`](https://github.com/kyren/piccolo/issues/38#issuecomment-1819824923):
<div data-copy/>

```rust
macro_rules! smaller_tuples_too {
    ($m: ident, $ty: ident) => {
        $m!{}
        $m!{$ty}
    };
    ($m: ident, $ty: ident, $($tt: ident),*) => {
        smaller_tuples_too!{$m, $($tt),*}
        $m!{$ty, $($tt),*}
    };
}
```

And now we can combine the two macros to generate 64 implementations of the
trait with a single macro call:
<div data-copy/>

```rust
#[rustfmt::skip]
smaller_tuples_too!(impl_type_list,
    A, B, C, D, E, F, G, H, I, J,
    K, L, M, N, O, P, Q, R, S, T,
    U, V, W, X, Y, Z, AA, AB, AC, AD,
    AE, AF, AG, AH, AI, AJ, AK, AL, AM, AN,
    AO, AP, AQ, AR, AS, AT, AU, AV, AW, AX,
    AY, AZ, BA, BB, BC, BD, BE, BF, BG, BH,
    BI, BJ, BK, BL
);
```

And just like that we've built a forward type iterator. You can give it a try in
the
[playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b4b5020a222aa2ea3cb93217187dff59)
([gist](https://gist.github.com/rust-play/b4b5020a222aa2ea3cb93217187dff59)).

You'll notice that it's quite a pickle to access n-th element as we have to
reaffirm the type of `Tail` for each level.

We have to reaffirm the `Tail` event though we have specified that `Tail:
TypeList`, because the compiler can't just assume the next `Tail` is being
accessed from `TypeList` vtable because the result `Tail` might implement some
other trait that also has a `Tail` associated type. `Tail` might be a bad
example because it's unique in our context, but consider the following:
```rust
trait MyTrait {
    type Error;
}
impl MyTrait for u32 {
    type Error = std::io::Error;
}

type Ambiguous = u32::Error; // Which Error?
type Explicit = <u32 as TryFrom<i32>>::Error; // TryFromIntError
```

## Function Traits

In order to make our lives easer, and turn the forward iterator into an actual
type list, we'll define a `get` function. That is, we would generaly reach for
functions to do that, but we're working with types instead of values, and
functions return a value. Thus, we have to resort to using type declarations. As
we'll have to perform operations on const numbers, and given that we're trying
to do all of this in stable Rust, we'll use
[`typenum`](https://github.com/paholg/typenum) crate.

Our `Get` function trait declaration is rather simple:
<div data-copy/>

```rust
trait TypeIndex<N> {
    type Value;
}
```

Our implementation of the trait (if it worked), would look something like:

```rust
use std::ops::Sub;
use typenum::{Gr, Sub1, Unsigned, B0, B1};

impl<L> TypeIndex<B0> for L
where
    L: TypeList,
{
    type Value = L::Head;
}

impl<N, L> TypeIndex<N> for L
where
    N: Unsigned + Sub<B1>,
    L: TypeList,
    Sub1<N>: Unsigned
{
    type Value = <L::Tail as TypeIndex<Sub1<N>>>::Value;
}
```

The issue with the above code stems from the fact (as the compiler tells us)
that `typenum` _could_ at some point implement `Sub1<N>: Unsigned` for `B0`.
This is wrong as there's no number lesser than `N = 0` which would satisfy the
`Unsigned` constraint, so `typenum` won't do that - the compiler can't
understand that though.

It's also true that at some point the upstream crate _might_ change and the
compiler can't guarantee our bounds to hold true which would in term cause
double/ambiguous implementation for `N = 0` case, evem though `typenum` would
still work just fine.

The compiler also gives us a hint through it's error message though - while we
can't guarantee the upstream crate won't change and break our code, we _can_
guarantee that _our_ code won't do so because then it won't compile. So what we
need is to express the same semantics, only without relying on `typenum` as our
discriminant between `L::Head` and `<L::Tail as Get<Sub1<N>>>::Value` cases.

To achieve this we want to copy `Sub1` from typenum, which is a type alias:
```rust
type Sub1<N> = <N as std::op::Sub<B1>>::Output;
```

## Operators

In order to do that, we need our own `Decrease` trait:

```rust
trait Decrease {
    type Value;
}

impl Decrease for U1 {
    type Value = U0;
}

impl Decrease for U2 {
    type Value = U1;
}

impl Decrease for U3 {
    type Value = U2;
}
// 61 more...
```

We can use macros again to reduce total amount of code:
<div data-copy/>

```rust
trait Decrease {
    type Value;
}

macro_rules! impl_decrease {
    ($current:ident, $next:ident) => {
        impl Decrease for typenum::$current {
            type Value = typenum::$next;
        }
    };
}

macro_rules! all_seq_pairs {
    ($m: ident, $ta: ident) => {};
    ($m: ident, $ta: ident, $tb: ident) => {
        $m!{$tb, $ta}
    };
    ($m: ident, $ta: ident, $tb: ident, $($tt: ident),*) => {
        $m!{$tb, $ta}
        all_seq_pairs!{$m, $tb, $($tt),*}
    };
}

#[rustfmt::skip]
all_seq_pairs!(impl_decrease,
    U0,U1,U2,U3,U4,U5,U6,U7,U8,U9,
    U10,U11,U12,U13,U14,U15,U16,U17,U18,U19,
    U20,U21,U22,U23,U24,U25,U26,U27,U28,U29,
    U30,U31,U32,U33,U34,U35,U36,U37,U38,U39,
    U40,U41,U42,U43,U44,U45,U46,U47,U48,U49,
    U50,U51,U52,U53,U54,U55,U56,U57,U58,U59,
    U60,U61,U62,U63
);
```

Now with our own decrement operator, we can finally express bounds for `Get` unambiguously:

```rust
impl<L> TypeIndex<typenum::U0> for L
where
    L: TypeList,
{
    type Value = L::Head;
}

impl<N, L> TypeIndex<N> for L
where
    N: Unsigned + Decrease,
    L: TypeList,
    <N as Decrease>::Value: Unsigned, // decreased value is unsigned
    L::Tail: TypeIndex<<N as Decrease>::Value>, // tail must be indexable
{
    type Value = <L::Tail as TypeIndex<<N as Decrease>::Value>>::Value;
}
```

With this nifty addition, we can substitute our previous chain of expressions with a single indexing operator and the compiler will do the rest:

```rust
type SixthElement = <SomeTypeList as TypeIndex<typenum::U5>>::Value;
```

You can try out this code on [playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=98836acb79ac49a15f465de5a010955a) ([gist](https://gist.github.com/rust-play/98836acb79ac49a15f465de5a010955a)).

Now that we've built the the getter, we have a good template to work with
while implementing the rest of the operators we might need. In order to properly
gauge that though it's time for us to start designing the user facing API so
that we get a better idea of what our exact requirements are.

## API-first approach

Throught the previous section we've solved all major issues that would've
prevented us from implementing the functionality we need if they didn't work
out. Now that we know we _can_ do it, we need to focus on what it is we're
trying to do.

Previously I would've just built all the operators one might need to use type
lists, but I've since found that the top-to-bottom approach is a lot more time
efficient as we won't be wasting time on funcionality we won't use. If I ever
turn the code in this article into a library, only _then_ bottom-to-top approach
would be a better fit - but as it currently stands, we're trying to solve a real
issues and not just play around with capabilities of the type system.

We want our `Model` trait to specify inputs and outputs in the type signature. The main issue with this is that traits need to generate a virtual table that's known to the compiler while `litesim` is being built. So the model **must** have a single method for handling all inputs/outputs.

Implementation of that method is however allowed branch off based on input/output index i.e. index of type in `I`/`O` type tuple. Our current design allows for labeled inputs and outputs as well.

A simplified version of a `litesim` model would now look like:
```rust
pub trait Event: 'static {}
impl<T> Event for T where T: 'static {}

pub trait Handler<'s, M, E>: Fn(&mut M, E) -> Result<(), String> + 'static {}
impl<'s, M, E, F> Handler<'s, M, E> for F where F: Fn(&mut M, E) -> Result<(), String> + 'static {}

trait Model<'s, I: TypeList, O: TypeList> {
    fn input_handler<Index: Unsigned>() -> (
        &'s str,
        &'s dyn Handler<'s, Self, <I as TypeIndex<Index>>::Value>,
    )
    where
        I: TypeIndex<Index>;

    // other methods...
}
```

I removed error details, `Event` wrapper struct and `ModelCtx` for brievity, but they basically provide additional information about failiure, `Event` type information and the surrounding models (in respective order). For context, `'s` lifetime represents the sumulated system - no model or any of its handlers are expected to live longer than the whole simulation.

We can see that:
- `Event` is basically any static type (type known at compile time).
- `Handler` is just a function that takes a mutable reference to the `Model` and consumes an `Event`.
- `Model::input_handler` takes a constant `Index` and should return the name of the input and corresponding (static) `Handler` function.

The issue with this approach however is that while the trait we specified is **valid**, it's next to impossible to implement properly. Even if the expected usage pattern worked for a single input:
```rust
impl<'s> Model<'s, (Ball,), ()> for Player {
    fn input_handler<U0>() -> (
        &'s str,
        &'s dyn Handler<'s, Self, Ball>,
    )
    where
        U0: Unsigned,
    {
        let handler: &'s dyn Handler<'s, Self, Ball> = &|_model, _event| Ok(());
        ("recieve", handler)
    }
}
```
the trait would still fail for multiple inputs due to "duplicate definitions" error and [specialization](https://github.com/rust-lang/rust/issues/31844) not being supported. In other words, we need to provide a single output from a function with a single definition that contains all the handlers.

## Type Mapping

In order to transform our list of inputs `(A, B, C)` into a return type we're expecting from our function:
```rust
type Result = (
    (&'s str, &'s dyn Handler<'s, Self, A>),
    (&'s str, &'s dyn Handler<'s, Self, B>),
    (&'s str, &'s dyn Handler<'s, Self, C>),
);
```
we need a way to perform a mapping operation on types. This is where shit hits the fan as we're looking at a very complex transformation. We just to try hard enough though because it _is_ possible... somehow... I'm almost certain.

Mapping is a composition of iteration (which we have), application and collection. So in order to perform application we need to figure out how to express it efficiently - ideally in a way we can re(ab)use multiple times.

We start with a trait (our version of "operator"):
```rust
trait Mapping<T> {
    type Value;
}
```
and implement it for our use case:
```rust
struct OurResult<'s> {
    _phantom: std::marker::PhantomData<&'s ()>,
}
impl OurResult<'_> {
    const fn new() -> Self {
        Self {
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<'s, T> Mapping<T> for OurResult<'s>
where
    T: 'static,
{
    type Value = (&'s str, &'s dyn Handler<'s, Self, T>);
}
```

We're using `Phantom` in `OurResult` because rust requires us to restrict `'s` in `Mapping<T>` implementation in the signature. I'd use `#[derive(Default)]`, but we need `OurResult` to be const-constructible.

Now that we're done with application part of our mapping, we need a collector that would allow us to create a tuple from a list of mapped input types.
