---
title: "Rust Metaprogramming"
summary: "They say macros are Rust equivalent of C++ metaprograming; I beg to differ."
date: "2024-01-05"
tags:
  - Rust
  - metaprogramming
  - abstraction
---

For one of my classes I wrote a discrete event simulation library in Rust. The
reason I wrote it was...

- I like Rust.
- I did very little reasearch into existing libraries.
- I needed filler for the essay as I covered the assigned topic and didn't have
  very many pages.

Notable ones (from my limited search) are
[`sympy`](https://gitlab.com/team-simpy/simpy) as the most used one by the
mainstream and [`asynchronix`](https://github.com/asynchronics/asynchronix) as
the most unique one.

## Introduction

While looking up related literature and resources I got a vibe that it was much
more popular 10-ish years ago, and I'm not sure why the hype died down. In
library space there's very few solutions being actively maintained.

I wanted to build something dumb simple to use that doesn't have as steep
learning curve as some other solutions in the space so I made
[`litesim`](https://github.com/Caellian/litesim) (and descibed it in the essay
ðŸ˜„). My teacher was like:

> I'm not sure _why_ you did it, that's more than I asked for. <span
> data-paraphrase></span>

which I guess is true, but I also felt like there was nothing simple enough for
use cases like mine where I was on a tight schedule and needed to write a
simulation **fast** without wasting time learning how to use 10 new concepts
introduced by a tool that's supposed to make things simpler.

So instead of making a simulation I made a discrete event simulation library
that I felt was the appropriate substitute. You could argue that the library was
a bigger waste of time, but don't try me because I win arguments even when I
know I'm wrong. <span data-tone=half-joke></span>

### LiteSim

Cool thing about litesim is that it basically erases all simulation internals
and leaves you with a clean slate when you're modelling a system. It's based on
[DEVS](https://en.wikipedia.org/wiki/DEVS) so the whole simulation is built out
of composable models. The only structs the user needs to interact with are
`SystemModel` and `Simulation`.

A simple ping-pong example requires less than 50 lines of code and very little
understanding of how the library works:

```rust
use litesim::prelude::*;

pub struct Player;

#[litesim_model]
impl<'s> Model<'s> for Player {
    #[input(signal)]
    fn receive(&mut self, ctx: ModelCtx<'s>) -> Result<(), SimulationError> {
        ctx.schedule_update(Now)?;
        Ok(())
    }

    #[output(signal)]
    fn send(&self) -> Result<(), SimulationError>;

    fn handle_update(&mut self, ctx: ModelCtx<'s>) -> Result<(), SimulationError> {
        log::info!(
            "Player {} got the ball at {}",
            ctx.model_id.as_ref(),
            ctx.time
        );
        self.send(In(ctx.rand_range(0.0..1.0)))?;
        Ok(())
    }
}

fn main() {
    env_logger::builder()
        .filter_level(log::LevelFilter::Info)
        .init();

    let mut system = SystemModel::new();

    system.push_model("p1", Player);
    system.push_model("p2", Player);

    system.push_route(connection!(p1::send), connection!(p2::receive));
    system.push_route(connection!(p2::send), connection!(p1::receive));

    let mut sim = Simulation::new(rand::thread_rng(), system, 0.0).expect("invalid model");

    sim.schedule_event(0.5, Signal(), connection!(p1::receive))
        .expect("unable to schedule initial event");

    sim.run_until(50.0).expect("simulation error");
}
```

Most of the heavy lifting is done by the `#[litesim_model]` proc macro. This
macro does a lot of code transformation in the background in order to make the
`impl` block look as simple as it does.

In minimal form, implementing `Model<'s>` with it looks like:
```rust
#[litesim_model]
impl<'s> Model<'s> for MyModel {}
```

The _generated code is type safe_, but if the user implements the `Model<'s>`
trait without the macro, they're allowed to send arbitrary data into outputs
which is not ideal. The macro ensures correctess by filling in specified output
parameter types manually into invoked function signature, but bad inputs really
only fail bacause argument and specified generic types don't match, not because
the function doesn't exist or some bounds weren't satisfied.

That's bad because the library assumes the provided type will be the same as the
one specified on the connecting input connector of another model. The other
model (generally) can't tell the adress doesn't hold a valid type which can then
cause undefined behavior. Even assuming the layout of both types is identical,
it's still a semantic error and likely violates the API of the recieving model.

There is no sane way to support this use case without resorting to type
metaprogramming. Macros can't handle the use case where `Model<'s>` might change
interface and lookup table(s) based on types litesim isn't aware of. So in order
to tackle this, I'd like to replace `Model<'s>` with something like:
```rust
type Model<'s, I, O> {
  // details...
}
```

## What Lists Are Made Of

We're trying to specify different model inputs/outputs as a list of types. Rust
doesn't have variable argument generics
([yet](https://github.com/rust-lang/rfcs/issues/376)), but it does have
primitive that can convey similar information - **tuples**.

Tuple is a runtime type though and the language doesn't have support for
operations we expect a list to support, and specifically doesn't support them
for _types_. Traits allow us however to add such information and `rustc` can
deal with it properly.

In order to have a useful type list, we need methods to at least:
- access type list **size**,
- access **head** element,
- access list **tail**,
- access n-th element, and
- check if `T` is contained in the list.

Type lists in C++ metaprogramming are built on the same principles, though they
are nicer to work with because of vararg generic support. Ideally, our _type
list_ type would be zero sized but given that tuples _are_ sized we can get
around it by storing our type list as an empty array (`[TypeList; 0]`).
`Phantom` might be more appropriate for this kind of use though.

## Type List Type

We start by defining a trait we can use to specify some arbitrary type list. Due
to lack of vararg generics there will be an upper bound to our list but thanks
to macros we can make it arbitrarily large. Relistically, we don't expect models
with more than 64 inputs and outputs.

We declare our list trait with some basic properties:
```rust
trait TypeList {
    type Head;
    type Tail: TypeList;
}
```

Now we can start implementing it for tuples we want to support:
```rust
impl TypeList for () {
    type Head = !;
    type Tail = ();
}
// Uhm...
```
We can't use never type `!` yet so we'll resort to using `()` instead. This
leaves us with no way to check if we're done iterating over our list so we need
to add that missing information. Given that the code for tuples will be
generated anyway, it's straightforward enough to add a `SIZE` constant.


```rust
trait TypeList {
    const SIZE: usize;
    type Head;
    type Tail: TypeList;
}

impl TypeList for () {
    const SIZE: usize = 0;
    type Head = ();
    type Tail = ();
}

impl<A> TypeList for (A,) {
    const SIZE: usize = 1;
    type Head = A;
    type Tail = ();
}

impl<A, B> TypeList for (A, B) {
    const SIZE: usize = 2;
    type Head = A;
    type Tail = (B,);
}

impl<A, B, C> TypeList for (A, B, C) {
    const SIZE: usize = 3;
    type Head = A;
    type Tail = (B, C);
}
// 61 more...
```

Now that we've written out the first four cases, we can politely ask our
friendly neighborhood LLM to convert it into a macro for us:
<div data-copy/>

```rust
macro_rules! impl_type_list {
    () => {
        impl TypeList for () {
            const SIZE: usize = 0;
            type Head = ();
            type Tail = ();
        }
    };
    
    ($A:ident) => {
        impl<$A> TypeList for ($A,) {
            const SIZE: usize = 1;
            type Head = $A;
            type Tail = ();
        }
    };
    
    ($A:ident, $($B:ident),*) => {
        impl<$A, $($B),*> TypeList for ($A, $($B),*) {
            const SIZE: usize = 1 + <($($B,)*) as TypeList>::SIZE;
            type Head = $A;
            type Tail = ($($B,)*);
        }
    };
}
```

Sadly this was the last place where LLMs prooved useful and from this point on
we're forced to not be replaced by AI ðŸ¤£

And apply some magic I picked up from
[`piccolo`](https://github.com/kyren/piccolo/issues/38#issuecomment-1819824923):
<div data-copy/>

```rust
macro_rules! smaller_tuples_too {
    ($m: ident, $ty: ident) => {
        $m!{}
        $m!{$ty}
    };
    ($m: ident, $ty: ident, $($tt: ident),*) => {
        smaller_tuples_too!{$m, $($tt),*}
        $m!{$ty, $($tt),*}
    };
}

// short for calling smaller_tuples_too with 64 arguments
macro_rules! all_supported_tuples {
    ($m: ident) => {
        #[rustfmt::skip]
        smaller_tuples_too!($m,
            A, B, C, D, E, F, G, H, I, J,
            K, L, M, N, O, P, Q, R, S, T,
            U, V, W, X, Y, Z, AA, AB, AC, AD,
            AE, AF, AG, AH, AI, AJ, AK, AL, AM, AN,
            AO, AP, AQ, AR, AS, AT, AU, AV, AW, AX,
            AY, AZ, BA, BB, BC, BD, BE, BF, BG, BH,
            BI, BJ, BK, BL
        );
    };
}
```

And now we can combine the two macros to generate 64 implementations of the
trait with a single macro call:
<div data-copy/>

```rust
all_supported_tuples!(impl_type_list);
```

And just like that we've built a forward type iterator. You can give it a try in
the
[playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b4b5020a222aa2ea3cb93217187dff59)
([gist](https://gist.github.com/rust-play/b4b5020a222aa2ea3cb93217187dff59)).

You'll notice that it's quite a pickle to access n-th element as we have to
reaffirm the type of `Tail` for each level.

We have to reaffirm the `Tail` event though we have specified that `Tail:
TypeList`, because the compiler can't just assume the next `Tail` is being
accessed from `TypeList` vtable because the result `Tail` might implement some
other trait that also has a `Tail` associated type. `Tail` might be a bad
example because it's unique in our context, but consider the following:
```rust
trait MyTrait {
    type Error;
}
impl MyTrait for u32 {
    type Error = std::io::Error;
}

type Ambiguous = u32::Error; // Which Error?
type Explicit = <u32 as TryFrom<i32>>::Error; // TryFromIntError
```

## Function Traits

In order to make our lives easer, and turn the forward iterator into an actual
type list, we'll define a `get` function. That is, we would generaly reach for
functions to do that, but we're working with types instead of values, and
functions return a value. Thus, we have to resort to using type declarations. As
we'll have to perform operations on const numbers, and given that we're trying
to do all of this in stable Rust, we'll use
[`typenum`](https://github.com/paholg/typenum) crate.

Our `Get` function trait declaration is rather simple:
<div data-copy/>

```rust
trait TypeIndex<N> {
    type Value;
}
```

Our implementation of the trait (if it worked), would look something like:

```rust
use std::ops::Sub;
use typenum::{Gr, Sub1, Unsigned, B0, B1};

impl<L> TypeIndex<B0> for L
where
    L: TypeList,
{
    type Value = L::Head;
}

impl<N, L> TypeIndex<N> for L
where
    N: Unsigned + Sub<B1>,
    L: TypeList,
    Sub1<N>: Unsigned
{
    type Value = <L::Tail as TypeIndex<Sub1<N>>>::Value;
}
```

The issue with the above code stems from the fact (as the compiler tells us)
that `typenum` _could_ at some point implement `Sub1<N>: Unsigned` for `B0`.
This is wrong as there's no number lesser than `N = 0` which would satisfy the
`Unsigned` constraint, so `typenum` won't do that - the compiler can't
understand that though.

It's also true that at some point the upstream crate _might_ change and the
compiler can't guarantee our bounds to hold true which would in term cause
double/ambiguous implementation for `N = 0` case, evem though `typenum` would
still work just fine.

The compiler also gives us a hint through it's error message though - while we
can't guarantee the upstream crate won't change and break our code, we _can_
guarantee that _our_ code won't do so because then it won't compile. So what we
need is to express the same semantics, only without relying on `typenum` as our
discriminant between `L::Head` and `<L::Tail as Get<Sub1<N>>>::Value` cases.

To achieve this we want to copy `Sub1` from typenum, which is a type alias:
```rust
type Sub1<N> = <N as std::op::Sub<B1>>::Output;
```

## Operators

In order to do that, we need our own `Decrease` trait:

```rust
trait Decrease {
    type Value;
}

impl Decrease for U1 {
    type Value = U0;
}

impl Decrease for U2 {
    type Value = U1;
}

impl Decrease for U3 {
    type Value = U2;
}
// 61 more...
```

We can use macros again to reduce total amount of code:
<div data-copy/>

```rust
trait Decrease {
    type Value;
}

macro_rules! impl_decrease {
    ($current:ident, $next:ident) => {
        impl Decrease for typenum::$current {
            type Value = typenum::$next;
        }
    };
}

macro_rules! all_seq_pairs {
    ($m: ident, $ta: ident) => {};
    ($m: ident, $ta: ident, $tb: ident) => {
        $m!{$tb, $ta}
    };
    ($m: ident, $ta: ident, $tb: ident, $($tt: ident),*) => {
        $m!{$tb, $ta}
        all_seq_pairs!{$m, $tb, $($tt),*}
    };
}

#[rustfmt::skip]
all_seq_pairs!(impl_decrease,
    U0,U1,U2,U3,U4,U5,U6,U7,U8,U9,
    U10,U11,U12,U13,U14,U15,U16,U17,U18,U19,
    U20,U21,U22,U23,U24,U25,U26,U27,U28,U29,
    U30,U31,U32,U33,U34,U35,U36,U37,U38,U39,
    U40,U41,U42,U43,U44,U45,U46,U47,U48,U49,
    U50,U51,U52,U53,U54,U55,U56,U57,U58,U59,
    U60,U61,U62,U63
);
```

Now with our own decrement operator, we can finally express bounds for `Get`
unambiguously:

```rust
impl<L> TypeIndex<typenum::U0> for L
where
    L: TypeList,
{
    type Value = L::Head;
}

impl<N, L> TypeIndex<N> for L
where
    N: Unsigned + Decrease,
    L: TypeList,
    <N as Decrease>::Value: Unsigned, // decreased value is unsigned
    L::Tail: TypeIndex<<N as Decrease>::Value>, // tail must be indexable
{
    type Value = <L::Tail as TypeIndex<<N as Decrease>::Value>>::Value;
}
```

With this nifty addition, we can substitute our previous chain of expressions
with a single indexing operator and the compiler will do the rest:

```rust
type SixthElement = <SomeTypeList as TypeIndex<typenum::U5>>::Value;
```

You can try out this code on
[playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=98836acb79ac49a15f465de5a010955a)
([gist](https://gist.github.com/rust-play/98836acb79ac49a15f465de5a010955a)).

Now that we've built the the getter, we have a good template to work with while
implementing the rest of the operators we might need. In order to properly gauge
that though it's time for us to start designing the user facing API so that we
get a better idea of what our exact requirements are.

## API-first approach

Throught the previous section we've solved all major issues that would've
prevented us from implementing the functionality we need if they didn't work
out. Now that we know we _can_ do it, we need to focus on what it is we're
trying to do.

Previously I would've just built all the operators one might need for use of
type lists, but I've since found that the top-to-bottom approach is a lot more
time efficient as we won't be wasting time on funcionality we won't use.

We want our `Model` trait to specify inputs and outputs in the type signature.
The main issue with this is that traits need to generate a virtual table that's
known to the compiler while `litesim` is being built. So the model **must** have
a single method for handling all inputs/outputs.

Implementation of that method is however allowed branch off based on
input/output index i.e. index of type in `I`/`O` type tuple. Our current design
allows for labeled inputs and outputs as well.

A simplified version of a `litesim` model would now look like:
```rust
pub trait Event: 'static {}
impl<T> Event for T where T: 'static {}

pub trait Handler<'s, M, E>: Fn(&mut M, E) -> Result<(), String> + 'static {}
impl<'s, M, E, F> Handler<'s, M, E> for F where F: Fn(&mut M, E) -> Result<(), String> + 'static {}

trait Model<'s, I: TypeList, O: TypeList> {
    fn input_connector<Index: Unsigned>(&self) -> (
        &'s str,
        &'s dyn Handler<'s, Self, <I as TypeIndex<Index>>::Value>,
    )
    where
        I: TypeIndex<Index>;

    // other methods...
}
```

I removed error details, `Event` wrapper struct and `ModelCtx` for brievity, but
they basically provide additional information about failiure, `Event` type
information and the surrounding models (in respective order). For context, `'s`
lifetime represents the sumulated system - no model or any of its connectors are
expected to live longer than the whole simulation.

We can see that:
- `Event` is basically any static type (type known at compile time).
- `Handler` is just a function that takes a mutable reference to the `Model` and
  consumes an `Event`.
- `Model::input_connector` takes a constant `Index` and should return the name
  of the input and corresponding (static) `Handler` function.

The issue with this approach however is that while the trait we specified is
**valid**, it's next to impossible to implement properly. Even if the expected
usage pattern worked for a single input:
```rust
impl<'s> Model<'s, (Ball,), ()> for Player {
    fn input_connector<U0>(&self) -> (
        &'s str,
        &'s dyn Handler<'s, Self, Ball>,
    )
    where
        U0: Unsigned,
    {
        let handler: &'s dyn Handler<'s, Self, Ball> = &|_model, _event| Ok(());
        ("recieve", handler)
    }
}
```
the trait would still fail for multiple inputs due to "duplicate definitions"
error and [specialization](https://github.com/rust-lang/rust/issues/31844) not
being supported. In other words, we need to provide a single output from a
function with a single definition that contains all the connectors.

## Type Mapping

In order to transform our list of inputs `(A, B, C)` into a return type we're
expecting from our function:
```rust
type Result = (
    (&'static str, &'s dyn Handler<'s, Self, A>),
    (&'static str, &'s dyn Handler<'s, Self, B>),
    (&'static str, &'s dyn Handler<'s, Self, C>),
);
```
we need a way to perform a mapping operation on types. This is where shit hits
the fan as we're looking at a very complex transformation. We just to try hard
enough though because it _is_ possible... somehow... I'm almost certain.

Mapping is a composition of iteration (which we have), application and
collection. So in order to perform application we need to figure out how to
express it efficiently - ideally in a way we can re(ab)use multiple times.

### Apply operator

We start with a trait - our version of "call this thing":
<div data-copy />

```rust
trait Apply {
    type Value;
}
```
and declare our "method":
```rust
struct ToInputConnector<Model> {
    _phantom: std::marker::PhantomData<Model>,
}
```
We're using `Phantom` in `ToInputConnector` because rust will require us to
restrict `'s` while we're trying to implement `Apply` in the signature.
`ToInputConnector` also contains any types which stay constant throughout the
mapping operation. The `ToInputConnector` type will never be constructed or used
at runtime though as it's effectively just a _compile time function signature_.

Then we can specify how the method is applied, i.e. the body of the method:
```rust
impl<M, T> Apply for (ToInputConnector<M>, T)
where
    M: 'static,
    T: 'static,
{
    type Value = (&'static str, &'static dyn Handler<M, T>);
}
```
You'll notice we're implementing the method for a tuple of method and arguments
(in this case one), that's because we have no other way of passing compile time
information into `Apply`:

- If we tried storing `T` as a generic on `Apply`, we wouldn't be able to invoke
it for different types.
- Conversly, if we tried storing it on `ToInputConnector`, then out collector
wouldn't be agnostic with respect to method it's applying.

So, in general, **variable types** are stored in the tuple we're calling `Apply`
on and **non-variable types** (such as `M` in example case) should go into the
signature struct (`ToInputConnector`).

While writing this article I also noticed that mapping with lifetimes doesn't
work, so I removed the system lifetime from `ToInputConnector` signature.
Compiler seems to fail at normalizing associated types on a trait that is
implemented for struct with a liftime ([minimal
reproduction](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b539abe29f693183c9b785c6f904f508);
[rustc issue](https://github.com/rust-lang/rust/issues/106569)). For future
reference, once the issue get fixed, lifetimes go on `ToInputConnector` or
whatever your equivalent is if they don't change through the mapping.

Note that multiple variable arguments will change how you implement
`TypeMapping` in the following section.

### Collector

Now that we're done with _application_ part of our mapping, we need a
**collector** that would allow us to create a tuple from a list of mapped input
types.

Sadly, this is a place we have to declare multiple implementations again for
each tuple size. As always, macros come to the rescue:
<div data-copy />

```rust
macro_rules! impl_mapping {
    () => {
        impl<Method> TypeMapping<Method> for ()
        {
            type Value = ();
        }
    };
    ($($A: ident),+) => {
        impl<Method, $($A),+> TypeMapping<Method> for ($($A,)+)
        where
            $((Method, $A): Apply),+
        {
            type Value = (
                $(<(Method, $A) as Apply>::Value,)+
            );
        }
    };
}

all_supported_tuples!(impl_mapping);
```
`TypeMapping` implementations here will change somewhat if your use case calls
for multiple variable types or lifetimes. They should be part of the tuple the
`TypeMapping` is implemented for.

You can see a simplified version without the invariant `M` (model) on the
[playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=47f94126ef98a825141343f04090dedb)([gist](https://gist.github.com/rust-play/47f94126ef98a825141343f04090dedb)).

## API-first approach; attempt no. 2

Surely we have enough type support now to make use of it?!

Our new `Model` and implementation for `Player` look as following:
```rust
struct ToInputConnector<Model> {
    _phantom: std::marker::PhantomData<Model>,
}
impl<M, T> Apply for (ToInputConnector<M>, T)
where
    M: 'static,
    T: 'static,
{
    type Value = (&'static str, &'static dyn Handler<M, T>);
}
struct ToOutputConnector;
impl<T> Apply for (ToOutputConnector, T)
    T: 'static,
{
    type Value = &'static str;
}

trait Model<'s, I: TypeList, O: TypeList>: Sized {
    fn input_connectors(&self) -> <I as TypeMapping<ToInputConnector<Self>>>::Value
    where
        I: TypeMapping<ToInputConnector<Self>>;

    fn output_connectors(&self) -> <O as TypeMapping<ToOutputConnector>>::Value
    where
        O: TypeMapping<ToOutputConnector>;

    // other functions...
}

struct Ball;
struct Player;

impl<'s> Model<'s, (Ball,), (Ball,)> for Player {
    fn input_connectors(&self) -> <(Ball,) as TypeMapping<ToInputConnector<Self>>>::Value
    where
        (Ball,): TypeMapping<ToInputConnector<Self>>,
    {
        (("recieve", handle_ball),)
    }
    fn output_connectors(&self) -> <(Ball,) as TypeMapping<ToOutputConnector>>::Value
    where
        (Ball,): TypeMapping<ToOutputConnector>,
    {
        ("send",)
    }
}

fn handle_ball(_model: &mut Player, _event: Ball) -> Result<(), String> {
    Ok(())
}
```

With that, connectors are done. I want to point out that the implementation
above (somewhat) successfully replaces a whole bunch of complicated code that
was previously generated by `#[litesim_model]`:
```rust
fn input_connectors(&self) -> Vec<&'static str> {
    vec!["receive"]
}
fn get_input_handler<'h>(&self, index: usize) -> Option<Box<dyn ErasedHandler<'h, 's>>>
where
    's: 'h,
{
    match index {
        0usize => {
            let handler: Box<&dyn Fn(&mut Player, Event<()>, ModelCtx<'s>) -> Result<(), SimulationError>> = Box::new(
                &(|_: &mut Player, _: Event<()>, ctx: ModelCtx<'s>| {
                    ctx.schedule_update(Now)?;
                    Ok(())
                }),
            );
            return Some(handler);
        }
        _ => return None,
    }
}
fn output_connectors(&self) -> Vec<OutputConnectorInfo> {
    vec![
        OutputConnectorInfo::new::<()>("send"),
    ]
}
```

Notably:
- We got rid of type erasure for `Handler`.
  - Now the `Model` will have to be type erased in order for us to store it in a
    `Vec`. That's however much safer and we can now hide a whole bunch of
    implementation details from end-user.
- Type signature dictates the number of connector labels and handlers which
  prevents invalid use.
  - Previously, the library would internally panic with somewhat obscure stack
    traces which made it hard for end-users to realize they're violating API
    requirements.
- Accessing a handler function and connector names is now (at least on this
  level) a `O(1)` operation instead of `O(n)`.
  - As the compiler knows where are handlers are, it can go crazy with
    optimizations.
  - `O(n)` doesn't capture the fact that we could've had _a lot_ of jumps on our
    hot path.

In the process we've also lost ability to change the number of inputs/outputs at
runtime, but that part of functionality required a rework anyway as it wasn't
completely sound. 

We'll deal with consumption of generated type signatures in a later post. We
didn't actually need the `TypeIndex` to express the trait at hand, but it will
be necessary for consuming generated types. In a later post I'll also go over
how we can bridge indices from runtime to compile time.
