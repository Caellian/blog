---
title: "Rust Type Metaprogramming: A List of Types"
summary: "Theory and practice of proof carrying code in Rust"
prev: "2025/type_theory"
next: "2025/metaprogramming_ex_nihilo"
toot: "111705676105732187"
tags:
  - Rust
  - metaprogramming
  - abstraction
---


<dl>
<lh>Terminology</lh>
<dt><a href="https://rustc-dev-guide.rust-lang.org/traits/goals-and-clauses.html#trait-ref">Associated type projection</a></dt>
<dd>resolution of a type from relative type path.</dd>
<dt>Type path</dt>
<dd>

a sequence of delimited type identifiers (with `::` in Rust)
whose resolution yields a type which is a child element of the initial type
structure (e.g. `FromStr::Err`). Not to be confused with
[paths in topology](https://proofwiki.org/wiki/Definition:Path_%28Topology%29).

</dd>
</dl>

## Changes

This article was modified to be a continuation onto a newer article that
introduces some basics about metaprogramming. This was necessary because the
initial version was very sparse on details and the article became too long and
hard to follow as I continued adding them.

## Context

It will go over type transformations that are necessary in order to provide
end-users with a type safe interface while reducing the area of library
internals they're exposed to.

Rust metaprogramming is generally done with macros, and when people in Rust
community say metaprogramming they usually refer to writing procedural macros.

- Macros do carry proof because code generated by macros will produce compiler
  errors when type requirements aren't met or the produced syntax is invalid.
- Macros however aren't ideal in some scenarios and allow end-users to violate
  semantic API requirements which can in turn cause undefined behavior or error
  messages which can't be easily controlled by API author.

## Prior Art

After writing the inital version of this post I stumbled upon a conference
talk ["Type Theory for the Working Rustacean"](https://www.youtube.com/watch?v=BdXWlQsd7RI)
by [Dan Pittman](https://dpitt.me/), which associates the ideas behind this
post with formal foundations in [type theory](https://en.wikipedia.org/wiki/Type_theory).

Other than that, I've only managed to find posts that describe metaprogramming
via macros in context of Rust:

- ["Understanding and Implementing Rust's Metaprogramming"](https://reintech.io/blog/understanding-implementing-rust-metaprogramming)
  by [_Reintech_](https://reintech.io/)
- ["That's so Rusty: Metaprogramming"](https://dev.to/imaculate3/that-s-so-rusty-metaprogramming-49mj)
  by [_imaculate_](https://imaculate.github.io/)
- ["Metaprogramming with macros"](https://subscription.packtpub.com/book/web-development/9781800560819/2/ch02lvl1sec07/metaprogramming-with-macros)
  by [_packt_ publishing](https://packtpub.com)
- ["Rust Macros â€” Advanced Use Cases, Metaprogramming Mastery, and Code Generation"](https://medium.com/@alexandragrosu03/rust-macros-advanced-use-cases-metaprogramming-mastery-and-code-generation-6c8216af5086)
  by [_Alexandra Grosu_](https://medium.com/@alexandragrosu03)
- and so on...

Another approach I came across, in article
["Type-directed metaprogramming in Rust"](https://willcrichton.net/notes/type-directed-metaprogramming-in-rust/)
by [_Will Crichton_](https://willcrichton.net), is using rustc API (rust compiler)
directly in order to achieve similar goals as this post, but internal rustc API
is unstable which makes this approach both harder to implement and more time
consuming to maintain across versions.

- I find it to be a great introduction to rust internals, HIR and AST
  representations.
- It makes sense to go that route it if one is developing something akin to
  [`c2rust`](https://github.com/immunant/c2rust/).

In general, type metaprogramming and macros/preprocessors strive to achieve
similar goals but through different means. Type metaprogramming usually achieves
greater level of integration with the language type system, at the cost of being
somewhat harder to write and debug. Conversely, macros and preprocessors can
(sometimes) provide much nicer error messages, are easier to reason about, but
are much more verbose to write and don't integrate into the build process quite
as nicely.

## Tuples As Type Lists

Lists are used to store varying number of **runtime values** of the same
compile-time type. Tuples are used to group _differently typed_ values with a
tradeoff of being fixed in size. Tuple size constraint as well as fixed typing
can't be circumvented, as that would void soundness of the type system. That is,
if one can achieve it, they've found a compiler or specification/implementation
bug.

<div class="strong-cols row-titles"></div>

|  Type | Type Constraint | Size Constraint |
| ----: | :-------------: | :-------------: |
| Array |     Uniform     |  Compile-time   |
|  List |     Uniform     |     Runtime     |
| Tuple |     Varying     |  Compile-time   |

The fixed size is enforced directly by local type signatures, but it can also be
inferred in languages that support one of specialization, templatization or
generic types. In other words, we can use a variety of methods to evaluate final
type elements - so long as we keep in mind that they will have to be inferred by
the compiler at compile-time.

Rust doesn't have variable argument generics
([yet](https://github.com/rust-lang/rfcs/issues/376)) which is a well-trodden
path of implementing this sort of functionality, but it's got one of the best
macro systems which can be used instead.

In order to manipulate a type list or (more correctly) sequence, destructuring
into **head** and **tail** elements is a necessity.

In homotopy type theory (HoTT) terms, a tuple (and thereby a `TypeList`) is
simply a product type. I'll ignore the arity of this type in the article because
we want to treat it like a growable container type, but it certainly has a
predefined one and this fact is also enforced by the rust compiler. In practice
supported tuple arity will make us generate $n$ separate implementations of
everything mentioned in this article, but to make the article readable let's
assume it's some large number:

$$
\begin{aligned}
    \mathrm{Tuple} : & \space A_0 \times A_1 \times \dots \times A_n\\
    \mathrm{Tuple} : & \equiv\Sigma_{(a_0: A_0)} \Sigma_{(a_1: A_1)} \cdots \Sigma_{(a_n: A_n)} A_n(a_0, a_1, \dots, a_{n-1})\\
    &\equiv(A_0,\,A_1,\dots,\,A_n)\\
    \mathrm{TypeList} :&\equiv \mathrm{Tuple}
\end{aligned}
$$

`head` element is always the first element of the tuple:

$$
\displaylines{
\mathrm{head}: (A_0,\ A_1,\dots,\ A_n) \to A_0\\
\mathrm{head}((a_0,\ a_1,\dots,\ a_n)) :\equiv a_0
}
$$

If a tuple is empty, then a `head` function doesn't exist. That is, it's not
defined for empty tuples. In Rust this can be expressed by projecting into a
[never type `!`](https://github.com/rust-lang/rust/issues/35121) - when it gets
added; or by using some sentinel zero-variant enum with the same semantics:

```rust
enum Never {}
```

<br/>

`tail` element is always the tuple without it's first (head) element:

$$
\displaylines{
\mathrm{tail}: (A_0,\ A_1,\dots,\ A_n) \to (A_1,\dots,\ A_n)\\
\mathrm{tail}((a_0,\ a_1,\dots,\ a_n)) :\equiv (a_1,\dots,\ a_n)
}
$$

Unlike `head`, `tail` can be defined for empty tuples to return another empty
tuple (similarly to how containers remain empty after calling `pop`/`remove`).

### Type Sequence Trait

It's a good idea to start by defining a trait that can be used to specify some
arbitrary type sequence. This will serve as an important stepping stone and make
out later implementation simpler. It's equivalent to above type theory
definition.

Due to lack of variable argument (vararg) generics, there must exist an upper
bound to supported sequence length ($n$ from last section), but thanks to macros
we can make it arbitrarily large. This is primarily a development inconvenience
as vararg generics end up producing the same executable code. Another
alternative would be using
[specialization](https://github.com/rust-lang/rust/issues/31844) with
[associated type defaults](https://github.com/rust-lang/rust/issues/29661), but
those two aren't that close to being supported either.

We declare our type sequence trait with previously mentioned fundamental
properties attached as we have limited use for an empty (marker) trait:

```rust
//#! file:"type_list.rs"
pub trait TypeList {
    type Head;
    type Tail: TypeList;
}

impl TypeList for () {
    type Head = Never; // Should be ! type; once it's supported
    type Tail = ();
}
impl<A> TypeList for (A,) {
    type Head = A;
    type Tail = ();
}
impl<A, B> TypeList for (A, B) {
    type Head = A;
    type Tail = (B,);
}

// and so on...
```

Now after seeing the first few cases, it's clearer that `TypeList`
implementations can be generalized and then generated using macros:

```rust
//#! copy file:"type_list.rs"
pub trait TypeList {
    type Head;
    type Tail: TypeList;
}

macro_rules! impl_type_list {
    () => {
        impl TypeList for () {
            type Head = ();
            type Tail = ();
        }
    };
    ($A:ident) => {
        impl<$A> TypeList for ($A,) {
            type Head = $A;
            type Tail = ();
        }
    };
    ($A:ident, $($B:ident),*) => {
        impl<$A, $($B),*> TypeList for ($A, $($B),*) {
            type Head = $A;
            type Tail = ($($B,)*);
        }
    };
}

macro_rules! smaller_tuples_too {
    ($m: ident, $ty: ident) => {
        $m!{}
        $m!{$ty}
    };
    ($m: ident, $ty: ident, $($tt: ident),*) => {
        smaller_tuples_too!{$m, $($tt),*}
        $m!{$ty, $($tt),*}
    };
}

// short for calling smaller_tuples_too with 64 arguments
macro_rules! all_supported_tuples {
    ($m: ident) => {
        #[rustfmt::skip]
        smaller_tuples_too!($m,
            A, B, C, D, E, F, G, H, I, J,
            K, L, M, N, O, P, Q, R, S, T,
            U, V, W, X, Y, Z, AA, AB, AC, AD,
            AE, AF, AG, AH, AI, AJ, AK, AL, AM, AN,
            AO, AP, AQ, AR, AS, AT, AU, AV, AW, AX,
            AY, AZ, BA, BB, BC, BD, BE, BF, BG, BH,
            BI, BJ, BK, BL
        );
    };
}
```

Combining the above two macros allows us to generate 64 implementations of the
trait with a single macro call:

```rust
//#! copy file:"type_list.rs"
all_supported_tuples!(impl_type_list);
```

And just like that we've built a mechanism for forward iteration. You can give
it a spin in the
[playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=9bab9b8c8284f08f50a1d2269da203f6)
([gist](https://gist.github.com/rust-play/9bab9b8c8284f08f50a1d2269da203f6)).

It's already noticeable how accessing the n-th element is inconvenient because we
need to cast the `Tail` type at each level. The casting is necessary because
`Tail` could satisfy multiple different traits with identically named associated
type.<br/>
This pain point can be alleviated, but I'll address it in a later post as
operations covered in this post don't require indexing. I just wanted to
acknowledge and point it out for now.

## Type Operations

In order to map types, we have to figure out how to express functions that
operate on _type values_. Compiled languages have a strict hierarchy of type
families which dictate when the type/data is available and how much information
about it is available at each execution stage:

<div class="strong-cols row-titles"></div>

|                        Name |                   Description                    |                 Type                 |          Size           |
| --------------------------: | :----------------------------------------------: | :----------------------------------: | :---------------------: |
|                        Kind |         Structure information of a type          |                Syntax                |    Compiler internal    |
|                        Type |         Property information of a value          |    Inheritance and/or composition    |          Known          |
|                       Trait |               Behavior information               |    Inheritance and/or composition    |          None           |
|                   Interface |              Structure information               |    Inheritance and/or composition    | Lower bound constraint  |
|    Partial Type<br/>(`dyn`) |     Partial information of value properties      | Partial (structure and/or interface) |         Unknown         |
|                    Constant |      Immutable value known at compile time       |                Known                 |          Known          |
|                    Variable |          Mutable value known at runtime          |                Known                 |          Known          |
|          Pointer<br/>(`*T`) | Pointer to location of (first) constant/variable |                Known                 | Known (if not sequence) |
| Address<br/>(`*u8`/`usize`) |   Memory address of (first) constant/variable    |                Erased                |         Unknown         |

In many cases the compiler handles conversion automatically - allowing a const
function call with runtime arguments. So in order for our types to stay in the
type space, all conversion must happen inside it. That's because constant
functions deal with discrete values and we want to manipulate types.

Rust allows handling of type projection via type aliases much as C++ does. In
Rust however, one relies on traits instead of classes for the same
functionality:

```rust
//#! name:"example"
trait TypeSpaceFunction<T> {
    // not yet valid syntax; see issue #29661
    type Value = (Transformed, T);
}
```

One notable difference is that in Rust, one can associate trait implementations
with some other data which simplifies how conditionals are handled:

```rust
//#! name:"example"
trait SplitFunction {
    type Value;
}
impl<T> SplitFunction for MyType<T> {
    type Value = T;
}
impl<T> SplitFunction for [T; N] {
    type Value = T;
}
```

In C++ template metaprogramming, ifs or filters have to be used in constant
expressions to achieve similar results.

## Generic Type Projection

With former utilities in mind we want to construct a way of mapping a type
sequence `(A, B, C)` into another, more complex, type sequence such as:
```rust
//#! name:"example"
type Result = (
    (&'static str, &'static dyn Handler<Self, A>),
    (&'static str, &'static dyn Handler<Self, B>),
    (&'static str, &'static dyn Handler<Self, C>),
);
```

To start with, a simple $I$ to $O$ type projection would be any mapping of shape:

$$
SimpleProjection: \Pi_{(i: I)} O(i)
$$

However, type lists pose a problem problem where the projection shape can't be
static due to variable number of input and output arguments. We already have
`smaller_tuples_too!` which bridges this gap.

Instead of writing a discrete implementation of projections for each supported
input type AND count, we perform elementwise lifting of projection logic to
generalize a single use-case (which doesn't exist yet) and make elementwise type
projection for `TypeList` simple to use.

This elementwise lifting is essentially `zipApply` of projection to `TypeList`:

$$
\mathrm{zipApply} :\equiv \mathrm{Y} (\lambda z \space \mathrm{fs} \space \mathrm{xs}.\mathrm{if} (\mathrm{isEmpty} \space \mathrm{fs}) [] (\mathrm{if} (\mathrm{isEmpty} \space \mathrm{xs}) [] (\mathrm{cons} ((\mathrm{head} \space \mathrm{fs}) (\mathrm{head} \space \mathrm{xs})) (\mathrm{z} (\mathrm{tail} \space \mathrm{fs}) (\mathrm{tail} \space \mathrm{xs})))))
$$

The only difference when working with Rust projections is that instead of
passing an actual function that performs a mapping to `zipApply`, we simply use
a _discriminant_ which allows the trait to be implemented for different
mappings. In effect, this allows us to map inputs to outputs by simply writing
the result type.<br/>
This makes our lives easier because we don't have to worry about the actual
operations that are needed to shape input types into outputs.

### Apply Operator

We start with the simple application trait:

```rust
//#! copy file:"mapping.rs"
trait Apply {
    type Value;
}
```

and declare the application discriminant ("function name"):

```rust
//#! file:"model.rs"
struct ToInputConnector<Model> {
    _phantom: std::marker::PhantomData<Model>,
}
```

The discriminant type (`ToInputConnector`) will never be constructed. Using it
allows the same `Apply` trait to be used for multiple different mappings which
makes it more ergonomic to import `Apply` operation.

I'm using `Phantom` in `ToInputConnector` because Rust will require `Model` to
be used in the signature of `Apply` implementation. Generally, any types that
stay constant across all mapping invocations have to be placed into the
`Phantom` here.

Then _method_ application can be specified (think of it as the body of the method):

```rust
//#! file:"model.rs"
impl<Model, T> Apply for (ToInputConnector<Model>, T)
where
    Model: 'static,
    T: 'static,
{
    type Value = (&'static str, &'static dyn Handler<Model, T>);
}
```

You'll notice I'm implementing the method for a tuple of method and arguments
(in this case a single one), that's because there's no other way of passing
compile time information into `Apply`:

- If we tried storing `T` as a generic on `Apply`, we wouldn't be able to invoke
  it for different types within the same type list.
- Conversly, if we tried storing it on `ToInputConnector`, then our mapping
  wouldn't be agnostic with respect to method it's applying.

To summarize, **variable types** are stored in the tuple we're calling `Apply`
on and **non-variable types** (such as `Model` in the example case) should go
into the implementation discriminant struct (`ToInputConnector`).

Note that multiple variable arguments will change how you implement
`TypeMapping` in the following section.

### Apply-to-all

Now that _application_ part of mapping is done with, all that's left is coupling
together all the operations to _apply_ the mapping _for every type_ in the list
_and return_ a new list with mapping results.

Sadly, this is a place multiple implementations are necessary again (for each
tuple size). As always, macros come to the rescue:

```rust
//#! copy file:"mapping.rs"
pub trait TypeMapping<Method> {
    type Value;
}

macro_rules! impl_mapping {
    () => {
        impl<Method> TypeMapping<Method> for ()
        {
            type Value = ();
        }
    };
    ($($A: ident),+) => {
        impl<Method, $($A),+> TypeMapping<Method> for ($($A,)+)
        where
            $((Method, $A): Apply),+
        {
            type Value = (
                $(<(Method, $A) as Apply>::Value,)+
            );
        }
    };
}

all_supported_tuples!(impl_mapping);
```

`TypeMapping` implementations here will change somewhat if multiple variable
types or lifetimes are needed.

You can try out a simplified version without the constant `M` type (for model)
on the
[playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=10f15816801e32933ed6777c02da93d2)([gist](https://gist.github.com/rust-play/10f15816801e32933ed6777c02da93d2)).

While writing this article, I also noticed that mapping with lifetimes doesn't
seem to work, so I removed the system lifetime from `ToInputConnector`
signature. Compiler seems to fail at normalizing associated types on a trait
that is implemented for struct with a lifetime ([minimal
reproduction](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b539abe29f693183c9b785c6f904f508);
[rustc issue](https://github.com/rust-lang/rust/issues/106569)). For future
reference (once the issue get fixed), lifetimes go on the discriminant struct if
they don't change for mapping applications, or alternatively, get paired with
types in tuples the `TypeMapping` is implemented for if they do change.

## Next posts

We'll deal with the consumption of generated type signatures in a later post, as
well as going over how we can write a getter for our type lists and bridge
indices from runtime to compile time.
